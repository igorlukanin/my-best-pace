<style>
    .athlete-pace-progress .line {
        fill: none;
    }

    .athlete-pace-progress .name {
        fill: #999;
        font: 12px sans-serif;
        text-anchor: end;
    }

    .athlete-pace-progress .pace {
        fill: #999;
        font: 12px sans-serif;
        text-anchor: start;
    }
</style>

<svg class="chart athlete-pace-progress"></svg>

<script>
    var data = <%- JSON.stringify(@analytics.distance_stats) %>;

    var minTimestamp, maxTimestamp, minPace, maxPace;

    for (var timestamp in data.all.date_groups) {
        if (data.all.date_groups.hasOwnProperty(timestamp)) {
            if (minTimestamp == undefined || minTimestamp > timestamp) {
                minTimestamp = timestamp;
            }

            if (maxTimestamp == undefined || maxTimestamp < timestamp) {
                maxTimestamp = timestamp;
            }

            if (minPace == undefined || minPace > data.all.date_groups[timestamp].min_pace) {
                minPace = data.all.date_groups[timestamp].min_pace;
            }

            if (maxPace == undefined || maxPace < data.all.date_groups[timestamp].max_pace) {
                maxPace = data.all.date_groups[timestamp].max_pace;
            }
        }
    }

    minPace = (Math.floor(minPace * 2) / 2).toFixed(1);
    maxPace = (Math.floor(maxPace * 2) / 2).toFixed(1);

    var lineAreaWidth = 950,
        paceAreaWidth = 50,
        width = lineAreaWidth + paceAreaWidth,
        dateAreaHeight = 25,
        lineAreaHeight = 375,
        height = dateAreaHeight + lineAreaHeight;

    var x = d3
        .scale
        .linear()
        .range([0, lineAreaWidth])
        .domain([minTimestamp, maxTimestamp]);

    var y = d3
        .scale
        .linear()
        .range([0, lineAreaHeight])
        .domain([maxPace, minPace]);

    var maxColorCount = 9;

    var chart = d3
        .select('.athlete-pace-progress')
        .attr('width', width)
        .attr('height', height);

    var i = 0;

    for (var distance in data) {
        if (data.hasOwnProperty(distance) && distance != 'all') {
            var lineData = [];

            for (timestamp in data[distance].date_groups) {
                if (data[distance].date_groups.hasOwnProperty(timestamp)) {
                    lineData.push([
                        x(timestamp),
                        y(data[distance].date_groups[timestamp].min_pace)
                    ]);
                }
            }

            var line = d3.svg
                .line()
                .interpolate('cardinal')
                .tension(0.9);

            chart
                .append('path')
                .datum(lineData)
                .attr('class', 'line')
                .attr('d', line)
                .attr('stroke', colorbrewer.Reds[maxColorCount][i < maxColorCount ? i : maxColorCount - 1]);

            i++;
        }
    }

    var year = new Date(minTimestamp * 1000);
    year.setDate(1);
    year.setMonth(1);

    while (year.getTime() / 1000 <= maxTimestamp) {
        year.setFullYear(year.getFullYear() + 1);

        chart
            .append('text')
            .attr('class', 'name')
            .attr('x', x(year.getTime() / 1000))
            .attr('y', lineAreaHeight + dateAreaHeight)
            .attr('dy', '-0.65em')
            .text(year.getFullYear());
    }

    var pace = +minPace;

    while (pace <= maxPace) {
        var minutes = Math.floor(pace),
            seconds = (pace - minutes) * 60;

        chart
            .append('text')
            .attr('class', 'pace')
            .attr('x', lineAreaWidth)
            .attr('y', y(pace))
            .attr('dx', '1em')
            .text(minutes + ':' + (seconds < 10 ? '0' + seconds : seconds));

        pace += 0.5;
    }
</script>